# 后端服务设计

## 1. 技术选型

*   **语言**: 当前采用Go来搭建服务框架，主要提供web,数据库，配置相关服务，[待定，后期有高性能模块考虑用c++实现]
*   **Web 框架**: Gin
*   **ORM**: GORM/sqlite3
*   **依赖管理**: Go Modules
*   **日志库**: **`uber-go/zap`**
*   **配置管理**: **Viper**
*   **测试框架**: Go 标准库 `testing` + Testify (可选，提供 Assertions)。
*   **高性能模块 (未来考虑)**: 特定性能瓶颈可能考虑 C++ 通过 IPC/gRPC 集成。
  
## 2. 内部架构/分层

推荐采用分层架构，后续会向多进程框架演进，如：

*   **Handler/Controller 层**: 接收 HTTP 请求，解析参数，调用 Service 层，组装响应。
*   **Service 层**: 实现核心业务逻辑，处理数据校验、事务管理、调用 Repository。
*   **Repository/DAL 层**: 负责与数据库交互，封装数据访问逻辑。
*   **Model 层**: 定义数据结构 (对应数据库表)。

## 3. 核心模块设计 (V1.0)

*   **用户认证与授权 (AuthN & AuthZ)**:
    *   实现登录接口，校验用户名密码，生成 JWT。
    *   设计中间件，拦截请求，校验 JWT，并将用户信息注入上下文。
    *   实现 RBAC 检查逻辑，根据用户角色和请求资源/操作进行权限判断。
*   **环境管理 (Environment)**:
    *   实现 CRUD 操作对应的 Service 和 Repository 逻辑。
    *   处理环境与服务实例、资产、职责组的关联关系。
*   **Bug 管理 (Bug)**:
    *   实现 Bug 提交逻辑，注意关联环境、服务、业务等信息。
    *   实现 Bug 状态流转逻辑。
    *   实现 Bug 分配逻辑 (V1.0 可能先手动分配，V1.1 考虑基于规则自动分配)。
*   **审计日志 (AuditLog)**:
    *   设计 AOP (面向切面编程) 方式或在 Service 层关键操作后显式记录审计日志。
    *   异步写入日志以减少对主流程性能影响。

## 4. 配置管理

*   使用 `viper` 库管理服务配置（数据库连接、端口、日志级别等）。
*   使用YAML，良好地支持数组结构，对于复杂嵌套结构的可读性好。
*   同时支持通过环境变量覆盖配置文件中的值。
*   考虑使用配置中心（如 Nacos, Consul）进行动态配置管理（未来）。

## 5. 日志记录

*   **日志库**: 选用 **`uber-go/zap`**。
    *   *理由*: 极致的性能和低内存分配，非常适合高并发场景。原生支持结构化日志和**采样 (Sampling)** 功能。
*   **结构化**: `zap` 强制或强烈推荐使用强类型的字段进行结构化日志记录。
*   **包含信息**: 日志条目应包含以下关键信息：
    *   **时间戳 (Timestamp)**: `zap` 自动添加。
    *   **日志级别 (Level)**: `zap` 自动添加。
    *   **消息内容 (Message)**: `zap` 自动添加。
    *   **代码位置 (Caller)**: 可通过配置开启。
    *   **进程号 (PID)**: 可在 Logger 初始化时配置添加为固定字段。
    *   **请求/追踪 ID (Request/Trace ID)**: 应在请求处理链路上传递，并通过 `Logger.With` 添加到日志上下文中。
    *   **结构化属性 (Fields)**: 使用 `zap.String()`, `zap.Int()`, `zap.Any()` 等方法添加键值对。
*   **输出与轮转**: 
    *   日志输出到文件。
    *   集成 **`natefinch/lumberjack.v2`** 库实现日志文件的**按大小轮转 (Rotation)** 和**自动压缩 (Compression)** (通过 `zapcore.AddSync(logWriter)` 集成)。
    *   开发环境下可同时输出到控制台 (使用 `zapcore.NewTee`)。
*   **动态级别调整**: 使用 **`zap.AtomicLevel`** 实现运行时的日志级别动态调整。
*   **采样**: 利用 `zap` 内建的**采样器 (Sampler)** 配置，在高频日志点减少日志量。
*   **集中化 (未来)**: 考虑将日志推送到日志平台 (如 ELK, Loki)。

## 6. 错误处理

*   **基本原则**: 错误处理应保持一致性、可预测性，并向 API 消费者提供清晰有效的信息，同时保护内部实现细节。
*   **错误包装 (Error Wrapping)**: 遵循 Go 1.13+ 规范，使用 `fmt.Errorf` 的 `%w` 动词在错误向上传递时添加上下文，保留原始错误信息。例如: `fmt.Errorf("service: failed to process order %d: %w", orderID, err)`。
*   **自定义错误类型 (Custom Error Types)**: 定义特定的错误类型（实现 `error` 接口的 struct）来表示业务或应用层错误，如 `ErrNotFound`, `ErrValidation`, `ErrPermissionDenied`。这有助于在 Handler 层进行类型断言 (`errors.As`) 并进行针对性处理。
*   **错误代码 (Error Codes)**: 定义一套内部错误代码（见 `docs/design/error_codes.md`），用于日志记录、监控和可能的 API 响应。可以在自定义错误类型中包含错误代码字段。
*   **分层处理 (Layered Handling)**:
    *   *Repository 层*: 处理数据库/存储错误，可能将其转换为通用的自定义错误（如 `ErrNotFound`）。
    *   *Service 层*: 处理业务逻辑错误，捕获或包装来自 Repository 层的错误。
    *   *Handler 层*: 作为错误处理边界。捕获来自 Service 层的**所有**错误，**绝不**直接暴露内部错误细节给客户端。根据错误类型或代码，将其**映射**为标准的 **HTTP 状态码** (4xx/5xx) 和**统一的 API 错误响应体**。
*   **日志记录**: 在 Handler 层返回响应前，记录**完整**的错误信息（包括错误链 `%+v`，如果使用支持堆栈的包装库）和请求上下文 (Request ID)，通常使用 `ERROR` 级别。
*   **标准化 API 错误响应**: 设计统一的 JSON 错误响应结构（参考 `docs/design/api_design.md` 中的示例），包含错误代码（可选）、用户友好的消息和可能的详细信息（如字段校验错误）。
*   **Gin 中间件**: 推荐使用 Gin 中间件实现集中的错误处理逻辑（捕获 error -> 映射 -> 记录日志 -> 返回标准响应）和 Panic 恢复 (`Recovery` 中间件)。

## 7. 与数据采集器通信 (V1.1+)

*   设计与采集器的通信协议（如 HTTP REST 或 gRPC）。
*   考虑安全性（如 mTLS 双向认证）。
*   处理异步任务（如下发日志获取指令并等待结果）。